// Targeted by JavaCPP version 1.5.6: DO NOT EDIT THIS FILE

package org.playstrategy;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class FairyStockfish extends org.playstrategy.FairyStockfishConfig {
    static { Loader.load(); }

@Name("std::map<std::string,fairystockfish::PieceInfo>") public static class PieceInfoMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PieceInfoMap(Pointer p) { super(p); }
    public PieceInfoMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef PieceInfoMap put(@ByRef PieceInfoMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native @ByRef PieceInfo get(@StdString BytePointer i);
    public native PieceInfoMap put(@StdString BytePointer i, PieceInfo value);

    public native void erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator *().second") @MemberGetter @ByRef @Const PieceInfo second();
    }
}

@Name("std::vector<std::string>") public static class VectorOfStrings extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VectorOfStrings(Pointer p) { super(p); }
    public VectorOfStrings(BytePointer value) { this(1); put(0, value); }
    public VectorOfStrings(BytePointer ... array) { this(array.length); put(array); }
    public VectorOfStrings(String value) { this(1); put(0, value); }
    public VectorOfStrings(String ... array) { this(array.length); put(array); }
    public VectorOfStrings()       { allocate();  }
    public VectorOfStrings(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator =") @ByRef VectorOfStrings put(@ByRef VectorOfStrings x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @StdString BytePointer get(@Cast("size_t") long i);
    public native VectorOfStrings put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index(function = "at") public native VectorOfStrings put(@Cast("size_t") long i, @StdString String value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @StdString BytePointer value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @StdString BytePointer get();
    }

    public BytePointer[] get() {
        BytePointer[] array = new BytePointer[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public BytePointer pop_back() {
        long size = size();
        BytePointer value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public VectorOfStrings push_back(BytePointer value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public VectorOfStrings put(BytePointer value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public VectorOfStrings put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public VectorOfStrings push_back(String value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public VectorOfStrings put(String value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public VectorOfStrings put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@NoOffset @Name("std::tuple<bool,int>") public static class BoolIntPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BoolIntPair(Pointer p) { super(p); }
    public BoolIntPair(@Cast("bool") boolean value0, int value1) { allocate(value0, value1); }
    private native void allocate(@Cast("bool") boolean value0, int value1);
    public BoolIntPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef BoolIntPair put(@ByRef BoolIntPair x);

    public @Cast("bool") boolean get0() { return get0(this); }
    @Namespace @Name("std::get<0>") public static native @Cast("bool") boolean get0(@ByRef BoolIntPair container);
    public int get1() { return get1(this); }
    @Namespace @Name("std::get<1>") public static native int get1(@ByRef BoolIntPair container);
}

@NoOffset @Name("std::tuple<bool,bool>") public static class BoolBoolPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BoolBoolPair(Pointer p) { super(p); }
    public BoolBoolPair(@Cast("bool") boolean value0, @Cast("bool") boolean value1) { allocate(value0, value1); }
    private native void allocate(@Cast("bool") boolean value0, @Cast("bool") boolean value1);
    public BoolBoolPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef BoolBoolPair put(@ByRef BoolBoolPair x);

    public @Cast("bool") boolean get0() { return get0(this); }
    @Namespace @Name("std::get<0>") public static native @Cast("bool") boolean get0(@ByRef BoolBoolPair container);
    public @Cast("bool") boolean get1() { return get1(this); }
    @Namespace @Name("std::get<1>") public static native @Cast("bool") boolean get1(@ByRef BoolBoolPair container);
}

// Parsed from fairystockfish.h

// #ifndef FAIRYSTOCKFISH_H
// #define FAIRYSTOCKFISH_H

// #include <sstream>

// #include "misc.h"
// #include "types.h"
// #include "bitboard.h"
// #include "evaluate.h"
// #include "position.h"
// #include "search.h"
// #include "syzygy/tbprobe.h"
// #include "thread.h"
// #include "tt.h"
// #include "uci.h"
// #include "piece.h"
// #include "variant.h"
// #include "apiutil.h"

// #include <vector>
// #include <map>


    // Copied from the apiutil.h
    /** enum fairystockfish::Notation */
    public static final int
        NOTATION_DEFAULT = 0,
        // https://en.wikipedia.org/wiki/Algebraic_notation_(chess)
        NOTATION_SAN = 1,
        NOTATION_LAN = 2,
        // https://en.wikipedia.org/wiki/Shogi_notation#Western_notation
        NOTATION_SHOGI_HOSKING = 3, // Examples: P76, Sâ€™34
        NOTATION_SHOGI_HODGES = 4, // Examples: P-7f, S*3d
        NOTATION_SHOGI_HODGES_NUMBER = 5, // Examples: P-76, S*34
        // http://www.janggi.pl/janggi-notation/
        NOTATION_JANGGI = 6,
        // https://en.wikipedia.org/wiki/Xiangqi#Notation
        NOTATION_XIANGQI_WXF = 7;
    @Namespace("fairystockfish") @MemberGetter public static native int VALUE_ZERO();
    @Namespace("fairystockfish") @MemberGetter public static native int VALUE_DRAW();
    @Namespace("fairystockfish") @MemberGetter public static native int VALUE_MATE();

    @Namespace("fairystockfish") @NoOffset public static class PieceInfo extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PieceInfo(Pointer p) { super(p); }
    
            public PieceInfo() { super((Pointer)null); allocate(); }
            private native void allocate();
            public PieceInfo(int pt) { super((Pointer)null); allocate(pt); }
            private native void allocate(int pt);

            public native int id();

            public native @StdString BytePointer name();
            public native @StdString BytePointer betza();
    }

    @Namespace("fairystockfish") public static native @Cast("bool") boolean _fairystockfish_is_initialized(); public static native void _fairystockfish_is_initialized(boolean setter);
    /**------------------------------------------------------------------------------
     *  Initialize the fairystockfish library.
     * ------------------------------------------------------------------------------ */
    
    ///
    @Namespace("fairystockfish") public static native void init();

    /**------------------------------------------------------------------------------
     *  Return the version of the library.
     * 
     *  returns a string version number
     * ------------------------------------------------------------------------------ */
    @Namespace("fairystockfish") public static native @StdString BytePointer version();

    /**------------------------------------------------------------------------------
     *  Print to stdout useful information about the library and enabled variants
     * ------------------------------------------------------------------------------ */
    
    ///
    @Namespace("fairystockfish") public static native void info();

    // pyffish methods

    /**------------------------------------------------------------------------------
     *  Sets one of the UCI options that fairy stockfish supports.
     * 
     *  @param name The name of the parameter to set.
     *  @param value The value of the parameters (in string form)
     * ------------------------------------------------------------------------------ */
    
    ///
    @Namespace("fairystockfish") public static native void setUCIOption(@StdString BytePointer name, @StdString BytePointer value);
    @Namespace("fairystockfish") public static native void setUCIOption(@StdString String name, @StdString String value);

    /**------------------------------------------------------------------------------
     *  Given a string containing .ini style configuration of variants, load them into
     *  the supported variants for Fairy Stockfish.
     * 
     *  @param config A string containing the ini style variant configuration. Please
     *                see https://github.com/ianfab/Fairy-Stockfish/blob/master/src/variants.ini
     *                for example of syntax.
     * ------------------------------------------------------------------------------ */
    
    ///
    @Namespace("fairystockfish") public static native void loadVariantConfig(@StdString BytePointer config);
    @Namespace("fairystockfish") public static native void loadVariantConfig(@StdString String config);

    /**------------------------------------------------------------------------------
     *  Returns the list of names of supported variants.
     * 
     *  @return A vector of variant names
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings availableVariants();

    /**------------------------------------------------------------------------------
     *  Returns the initial FEN for a given variant name. Note that this method does
     *  not check that the variant you provided is within the set of supported
     *  variants.
     * 
     *  @param variantName The name of the supported variant.
     * 
     *  @return A string representing the starting FNE for this variant.
     * ------------------------------------------------------------------------------ */
    
    ///
    @Namespace("fairystockfish") public static native @StdString BytePointer initialFen(@StdString BytePointer variantName);
    @Namespace("fairystockfish") public static native @StdString String initialFen(@StdString String variantName);

    /**------------------------------------------------------------------------------
     *  Returns a map from the name of a piece to information about that piece.
     * 
     *  @return The map
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal PieceInfoMap availablePieces();

    /**------------------------------------------------------------------------------
     *  Converts a UCI move into a SAN notation move given the variant and fen and
     *  whether it's chess960 or not.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMove The move in UCI notation.
     *  @param isChess960 Whether the game is chess960 or not.
     *  @param notation The desired SAN notation.
     * 
     *  @return The move in SAN notation
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @StdString BytePointer getSAN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @StdString BytePointer uciMove,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("fairystockfish::Notation") int notation/*=fairystockfish::Notation::NOTATION_DEFAULT*/
        );
    @Namespace("fairystockfish") public static native @StdString BytePointer getSAN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @StdString BytePointer uciMove
        );
    @Namespace("fairystockfish") public static native @StdString String getSAN(
            @StdString String variantName,
            @StdString String fen,
            @StdString String uciMove,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("fairystockfish::Notation") int notation/*=fairystockfish::Notation::NOTATION_DEFAULT*/
        );
    @Namespace("fairystockfish") public static native @StdString String getSAN(
            @StdString String variantName,
            @StdString String fen,
            @StdString String uciMove
        );

    /**------------------------------------------------------------------------------
     *  Converts a set of UCI moves to SAN notation given the variant and fen and
     *  whether it's chess960 or not.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     *  @param notation The desired SAN notation.
     * 
     *  @return A vector of moves in SAN notation
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getSANMoves(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("fairystockfish::Notation") int notation/*=fairystockfish::Notation::NOTATION_DEFAULT*/
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getSANMoves(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getSANMoves(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("fairystockfish::Notation") int notation/*=fairystockfish::Notation::NOTATION_DEFAULT*/
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getSANMoves(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Get legal moves from a given FEN and move list.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return a vector of legal moves in UCI notation
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getLegalMoves(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getLegalMoves(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getLegalMoves(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal VectorOfStrings getLegalMoves(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Get the resulting FEN from a given FEN and move list
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     *  @param sFen Whether the output is in sFen notation? (I'm guessing here)
     *  @param showPromoted Whether the fen includes promoted pieces (I'm guessing here)
     *  @param countStarted No clue. (probably has to do with games that end by certain
     *                      types of counts, like repetitions?)
     * 
     *  @return the FEN of the new position
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @StdString BytePointer getFEN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("bool") boolean sFen/*=false*/,
            @Cast("bool") boolean showPromoted/*=false*/,
            int countStarted/*=0*/
        );
    @Namespace("fairystockfish") public static native @StdString BytePointer getFEN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @StdString String getFEN(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            @Cast("bool") boolean sFen/*=false*/,
            @Cast("bool") boolean showPromoted/*=false*/,
            int countStarted/*=0*/
        );
    @Namespace("fairystockfish") public static native @StdString String getFEN(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Get check status from a given fen and movelist.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return the FEN of the new position
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @Cast("bool") boolean givesCheck(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean givesCheck(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean givesCheck(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean givesCheck(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Gets result from a given FEN, considering variant end, checkmate and stalemate
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return Returns an integer that represents the result (don't know what it
     *          means yet
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native int gameResult(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native int gameResult(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native int gameResult(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native int gameResult(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Figures out if variant rules immediately end the game
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return Returns a boolean indicating if the game is an immediate end as well
     *          as the integer result value.
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isImmediateGameEnd(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isImmediateGameEnd(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isImmediateGameEnd(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isImmediateGameEnd(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Get result from given FEN if rules enable game end by player.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     *  @param countStarted No clue. (probably has to do with games that end by certain
     *                      types of counts, like repetitions?)
     * 
     *  @return Returns a boolean indicating if the game is an immediate end as well
     *          as the integer result value.
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isOptionalGameEnd(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            int countStarted/*=0*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isOptionalGameEnd(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isOptionalGameEnd(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/,
            int countStarted/*=0*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolIntPair isOptionalGameEnd(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Checks for insufficient material on behalf of both players.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param uciMoves A vector of moves in UCI notation
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return Returns two booleans, one for each player which indicate if that player
     *          has sufficient material
     * ------------------------------------------------------------------------------ */
    
    ///
    ///
    @Namespace("fairystockfish") public static native @ByVal BoolBoolPair hasInsufficientMaterial(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolBoolPair hasInsufficientMaterial(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @ByVal VectorOfStrings uciMoves
        );
    @Namespace("fairystockfish") public static native @ByVal BoolBoolPair hasInsufficientMaterial(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @ByVal BoolBoolPair hasInsufficientMaterial(
            @StdString String variantName,
            @StdString String fen,
            @ByVal VectorOfStrings uciMoves
        );

    /**------------------------------------------------------------------------------
     *  Validates an input FEN.
     * 
     *  @param variantName The variant for the fen
     *  @param fen The FEN of the current possition
     *  @param isChess960 Whether the game is chess960 or not.
     * 
     *  @return Whether the FEN is valid or not.
     * ------------------------------------------------------------------------------ */
    @Namespace("fairystockfish") public static native @Cast("bool") boolean validateFEN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean validateFEN(
            @StdString BytePointer variantName,
            @StdString BytePointer fen
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean validateFEN(
            @StdString String variantName,
            @StdString String fen,
            @Cast("bool") boolean isChess960/*=false*/
        );
    @Namespace("fairystockfish") public static native @Cast("bool") boolean validateFEN(
            @StdString String variantName,
            @StdString String fen
        );


// #endif // FAIRYSTOCKFISH_H


}
